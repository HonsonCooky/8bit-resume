<hgroup style="margin-bottom: 4em">
    <h1>WHAT IS A SOFTWARE ENGINEER? - WIP</h1>
    <h3>An Observation By: Harrison Cook</h3>
    <p>10/09/2024</p>
</hgroup>
<article>
    <h3>Overview</h3>
    <p>
        There is plenty of debates online around the "correct" definition of a "Software Engineer". Whilst I can't say
        I've read everything - I often find these discussions focusing on measurable characteristics (e.g. can you call
        yourself a Software Engineer without a degree?) Whilst the focus on material components is critical for finding
        the truth in scientific discussions - they often offer no utility in matters of philosophy; Which is precisely
        where I think this conversation should land. In this post, I'd like to share some ideas that I've constructed
        based around the idea of "qualia" - and the utility of correctly understanding your own strengths and weaknesses
        - specifically around the topic of Software Engineering.
    </p>
    <p>
        <b><i>Biases:</i></b> I'm a Software Engineer by degree (Bachelor of Engineering) and by occupation. I've come
        across these ideas because of the friction I've felt transitioning from an academic to a commercial environment.
    </p>
    <p>
        <b><i>Note:</i></b> This post delves into some philosophical territory, but the ideas should be consumable
        without prior knowledge. Writing is not my strong suit (where I'd be much better explaining this in person) - so
        whilst I've done my best to communicate this idea through text, it would help to leave your existing opinions
        about this topic at the door. Of course, I don't mind critiques - but I'm not confident that existing
        conclusions (or arguments you've heard) are helpful or relevant here.
    </p>

    <br />

    <h3>Oversimplified Context</h3>
    <p>
        To ensure we are on the same page, a large amount of the following ideas focus around the concept of "qualia" -
        an individuals subjective experiences. Generally speaking, human brains are limited in their computational
        power. They take shortcuts and fill in missing information to make sense of the unimaginably large amount of
        variables and information that is packed into the universe. For example, the color purple is perceived by your
        brain when it interprets simultaneous signals from both red and blue light receptors in your eyes - however,
        there is no real way of knowing that two brains have recreated the exact same color. The color you see is a
        basic example of your subjective experience.
    </p>
    <p>
        Whilst qualia is the result of how your brain interprets the world, we can share qualia with others. Take the
        following math equation:
        <code>50 * 14</code>. If you asked a dozen people to solve this equation in their head - and then asked them how
        they found the answer (regardless if they were right or not), you'll probably find there was a selection of
        different methods to solving the equation. Some people may have done <code>100 * 7</code>, others may have done
        <code>50 * 10 + 50 * 4</code>. Whilst there are many different ways of solving this problem - there will be
        people that did it "your" way, and others who did not. You have a shared quale (singular qualia) with people who
        solved the problem the same way you did - in that, you're brain and their brain interpreted had the same "best"
        way to solve the problem.
    </p>
    <p>
        The collection of all your qualia that makes you different from everyone else. However, I would like to propose
        an idea that focuses on one specific set of qualia - interpretations of the relationship between code and CPU?
        In my experience, having shared qualia in this specific area can be the difference between easy and difficult
        conversations.
    </p>

    <br />

    <h3>A Spectrum Of Code Interpretations</h3>
    <p>
        The digital world as we know it has grown to an unfathomable scale! Assuming human brain limitations exist (as
        mentioned previously), any one person cannot be an expert at everything in this field; Where "everything"
        encompasses mathematical principles to continuous integration cloud tools, and "expert" implies you're capable
        of contributing to the pioneered progression of some subject (deep understanding AND feeling). I theorize that
        excelling in any particular field requires a specialized "qualia". However, at some point your brain must simply
        "fill in the blanks", but where that point is makes the difference. The natural progression of programming (from
        Alan Turing's theories on computational devices to monolith AWS applications) suggests a continuum of where
        these qualia may lie. We could outline the spectrum as such:
    </p>

    <ul>
        <li>
            <b>Theoretical - Computer Scientists</b>
            <p>
                Based heavily in mathematics, Computer Scientists have a set of qualia that is able to make sense of
                logical structures, abstract algorithms, and complex computational problems. This unique perspective
                allows them to drive innovation in theoretical technology.
            </p>
        </li>
        <li>
            <b>Practical - Software Engineers</b>
            <p>
                Turning theory into practice requires an intimate understanding of real world constraints. Software
                Engineers have a set of qualia that enables them to command interactions with computers - seeing the
                minute instructions and actions required to see theory come to life.
            </p>
        </li>
        <li>
            <b>Abstract - Software Developers</b>
            <p>
                Expanding the capabilities of computers for non-technical users requires stitching together a wide range
                of technologies, algorithms, components, etc. For Software Developers, their qualia thrives on the
                abstract - enabling the implementation and management that drives the utility of computing.
            </p>
        </li>
    </ul>

    <p>
        To be crystal clear, the markers above exist as transitions along a continuum. They are not boxes to put each
        individual into, but rather, indicators along a spectrum.
    </p>

    <br />

    <h3>Anecdotal Evidence - Languages</h3>
    <p>
        With the established spectrum above (and trusting in my proposed model for a moment), lets just discuss some
        anecdotal cases that made me think this model has some merit.
    </p>
    <p>
        <code>Haskell</code> is colloquially known as a "white paper" language - and for good reason. It bridges the gap
        between academic theory and practical implementations, incorporating principles from mathematical research like
        pure functions, lazy evaluation, and advanced type systems. These features, derived from scholarly work, make
        Haskell a powerful tool that transforms theoretical concepts into real-world programming solutions. On our
        spectrum, it would sit between "Theoretical" and "Practical" - meaning those with lambda calculus orientated
        qualia would have a much easier time using this language in it's intended fashion; Enabling the development of
        mathematical theory.
    </p>
    <p>
        <code>JavaScript</code> is often considered a quirky language, frequently ridiculed for its seemingly unexpected
        behaviors. Despite its reputation, JavaScript thrives in the hands of developers who can embrace a sense of
        blind trust. On the spectrum, it would heavily favor those with qualia towards the "Abstract". When combined
        with <code>Node.js</code> and <code>NPM </code>, there is an environment that excels for developers who can
        build efficiently without needing an in-depth understanding beyond an APIs. The frequent release of new
        JavaScript frameworks is often laughed at, but for those with the right qualia, picking up a new framework is a
        trivial task - and the breadth of frameworks enables more specialized implementations. Building larger
        applications becomes significantly more manageable for those in this headspace, allowing developers to focus on
        rapid development.
    </p>
    <p>
        <code>C#</code> has similar characteristics to JavaScript - but brings more structure and rigor to the field.
        Dependency Injection, SOLID Principles and Project Structures are added to the mix, making C# this odd language
        that feels like it sits between "Practical" and "Abstract" (arguably with a heavier lean towards "Abstract"). On
        one hand, the emphasised reliance on decoupled components and multi-paradigm capabilities means that there is
        strong similarities to JavaScript - where blind trust qualia can thrive. On the other hand, the static type
        system and structured environment forces a compile-time correctness that requires developers have some
        understanding of how their code works underneath.
    </p>
    <p>
        Lastly, <code>C/C++</code>, <code>Rust</code> and <code>Zig</code> would probably fall somewhere around the
        "Practical" marker. In these languages, you are required to understand what you're doing. Calling an interface
        at the wrong time or using the heap instead of the stack can lead to some pretty gnarly bugs. Successfully
        building with these languages requires some in-depth knowledge about how things work under the hood. With so
        much to know and remember, it's hard to build large scale applications with this qualia.
    </p>

    <br />

    <h3>Anecdotal Evidence - Phenomena</h3>
    <p>
        There are a few phenomena that have occurred over the last decade - that could be explained by a mismatch of
        qualia to environment. When you're working in an environment that is not particularly suited to the way your
        brain interprets code, you'll probably find it a lot more difficult. Likewise - those who have a matched qualia
        with their environment find it a lot easier. The emergence of people who identify as "&lt;Framework&gt;
        Developers" probably find their knowledge in said framework to be hard-earned - whilst others have been able to
        pick it up in a day. Furthermore, the "it's common sense" online culture could be (in some cases) mismatched vs
        matched qualia clashing online. Perhaps the reason we can't find a strict set of rules that makes code
        "readable" and "maintainable" is because these differ depending on the qualia match-up of each individual. Code
        comments are critical in environments that are mis-matched to your qualia, and totally unnecessary when working
        with languages that "speak for themselves" (a.k.a. matched qualia).
    </p>
    <p>
        Personally, I've really struggled to become a <code>C#</code> developer. I'm very capable of building working
        solutions - but my solutions have often got <code>C#</code> specific smells or antipatterns. Alternatively,
        <code>JavaScript</code>, <code>F#</code>, <code>Zig</code>, and <code>C</code> have all come very naturally to
        me. <code>Rust</code> and <code>C++</code> have provided a little more difficulty - not with memory management,
        but rather, just the sheer amount of learning required. Yet <code>Ruby</code> and <code>Haskell</code> feel like
        a foreign languages to me. My question that spawned most of this article is: "why?". I feel like I'm a capable
        and competent Software Engineer - but why do I struggle so much with some technologies, and not others? There
        doesn't seem to be some commonality with proximity to metal or user; Nor is there any commonality around
        paradigms.
    </p>
    <p>
        I'm at a stage in my career now, where I've dealt in some situations where I felt like I just could not
        communicate with my fellow Software Engineers. I've found myself questioning the competency of senior 
        developers (as an intermediate), and 
    </p>
</article>
