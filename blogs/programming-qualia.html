<hgroup style="margin-bottom: 4em">
    <h1>WHAT IS A SOFTWARE ENGINEER? - WIP</h1>
    <h3>An Observation By: Harrison Cook</h3>
    <p>29/12/2024</p>
</hgroup>
<article>
    <h3>Introductions and Biases</h3>
    <p>
        After spending four long and difficult (albeit - incredibly fulfilling) years at University, I graduated with a
        Bachelor of Engineering - majoring in Software Engineering. Completing this degree gave me euphoria - in that I
        seriously believed I had found my calling in this world. Feeling competent and capable to join the workforce, I
        was eager to grow stronger and expand into specializations based on my academic fundamentals. As many have
        experienced (and documented) before me, this was not the reality I found myself in. An analogy I've used to
        describe this odd position is:
    </p>
    <blockquote>
        Pretend I'm passionate about (and have trained to) build car engines as an "Automotive Engine Designer" - yet I
        find myself working as an "Automotive Service Technician".
    </blockquote>
    <p>
        These are both critical roles in the automotive space, and they do have some overlap, but they require wildly
        different ways of thinking about a vehicle. In this case though - both occupations have the same name.
    </p>
    <p>
        I've really struggled with understanding what this problem is. For me, this isn't a case of "University didn't
        prepare me for the real world" (as so many have described), because my education really did prepare me for the
        career I would like to pursue. In this post, I'd like to propose a new perspective on this topic that highlights
        the feeling of disconnect I (and others) have encountered. Fair warning though - this post does not offer
        solutions, but rather, a new way to highlight some communication problems found in the programming eco-sphere.
    </p>
    <p>
        I was introduced to the idea of "qualia" from a friend & flatmate. A couple drinks and qualia as a conversation
        topic is a recipe for 3 hour discussions between us. Some years ago, this was just a neat philosophical concept,
        that I didn't pay much attention to before. In a recent bout of exploring this concept together, it dawned upon
        me - my qualia from University is not the qualia I need for my occupation. I'm interpreting
    </p>

    <br />

    <h3>Background Information</h3>
    <p>
        The following ideas focus around the concept of "qualia" - an individuals subjective experiences. Generally
        speaking, human brains are limited in their computational power. They take shortcuts and fill in missing details
        to make sense of the unimaginably large amount of variables and information that is packed into the universe.
        Whilst qualia is the result of how your unique brain interprets the world, we can share qualia with others. Take
        the following math equation: <code>50 * 14</code>. If you asked a dozen people to solve this equation in their
        head - and then asked them how they found the answer, you'll probably find there was a selection of different
        methods to solving the equation. In the small sample I took there was <code>100 * 7</code>,
        <code>50 * 10 + 50 * 4</code>, <code>100 * 14 / 2</code>. Whilst there are many different ways of solving this
        problem - there will be people that did it "your" way, and others who did not. You have a shared quale (singular
        qualia) with people who solved the problem the same way you did - in that, you're brain and their brain
        interpreted the same "best" way to solve the problem.
    </p>
    <p>
        You are unique because of the specific combination of qualia that you have. Whilst this is a very interesting
        topic, I would like to explore a narrow spectrum of this concept - the qualia of code.
    </p>

    <br />

    <h3>A Spectrum Of Code Interpretations</h3>
    <p>
        The digital world as we know it has grown to an unfathomable scale! Assuming human brain limitations exist (as
        mentioned previously), any one person cannot be an expert at everything in this field; Where "everything"
        encompasses mathematical principles to continuous integration cloud tools, and "expert" implies you're capable
        of contributing to the pioneered progression of some subject (deep understanding AND feeling). I theorize that
        excelling in any particular field requires a specialized "qualia". However, at some point your brain must simply
        "fill in the blanks", but where that point is makes the difference. The natural progression of programming (from
        Alan Turing's theories on computational devices to monolith AWS applications) suggests a continuum of where
        these qualia may lie. We could outline the spectrum as such:
    </p>

    <ul>
        <li>
            <b>Theoretical - Computer Scientists</b>
            <p>
                Based heavily in mathematics, Computer Scientists have a set of qualia that is able to make sense of
                logical structures, abstract algorithms, and complex computational problems. This unique perspective
                allows them to drive innovation in theoretical technology.
            </p>
        </li>
        <li>
            <b>Practical - Software Engineers</b>
            <p>
                Turning theory into practice requires an intimate understanding of real world constraints. Software
                Engineers have a set of qualia that enables them to command interactions with computers - seeing the
                minute instructions and actions required to see theory come to life.
            </p>
        </li>
        <li>
            <b>Abstract - Software Developers</b>
            <p>
                Expanding the capabilities of computers for non-technical users requires stitching together a wide range
                of technologies, algorithms, components, etc. For Software Developers, their qualia thrives on the
                abstract - enabling the implementation and management that drives the utility of computing.
            </p>
        </li>
    </ul>

    <p>
        To be crystal clear, the markers above exist as transitions along a continuum. They are not boxes to put each
        individual into, but rather, indicators along a spectrum.
    </p>

    <br />

    <h3>Anecdotal Evidence - Languages</h3>
    <p>
        With the established spectrum above (and trusting in my proposed model for a moment), lets just discuss some
        anecdotal cases that made me think this model has some merit.
    </p>
    <p>
        <code>Haskell</code> is colloquially known as a "white paper" language - and for good reason. It bridges the gap
        between academic theory and practical implementations, incorporating principles from mathematical research like
        pure functions, lazy evaluation, and advanced type systems. These features, derived from scholarly work, make
        Haskell a powerful tool that transforms theoretical concepts into real-world programming solutions. On our
        spectrum, it would sit between "Theoretical" and "Practical" - meaning those with lambda calculus orientated
        qualia would have a much easier time using this language in it's intended fashion; Enabling the development of
        mathematical theory.
    </p>
    <p>
        <code>JavaScript</code> is often considered a quirky language, frequently ridiculed for its seemingly unexpected
        behaviors. Despite its reputation, JavaScript thrives in the hands of developers who can embrace a sense of
        blind trust. On the spectrum, it would heavily favor those with qualia towards the "Abstract". When combined
        with <code>Node.js</code> and <code>NPM </code>, there is an environment that excels for developers who can
        build efficiently without needing an in-depth understanding beyond an APIs. The frequent release of new
        JavaScript frameworks is often laughed at, but for those with the right qualia, picking up a new framework is a
        trivial task - and the breadth of frameworks enables more specialized implementations. Building larger
        applications becomes significantly more manageable for those in this headspace, allowing developers to focus on
        rapid development.
    </p>
    <p>
        <code>C#</code> has similar characteristics to JavaScript - but brings more structure and rigor to the field.
        Dependency Injection, SOLID Principles and Project Structures are added to the mix, making C# this odd language
        that feels like it sits between "Practical" and "Abstract" (arguably with a heavier lean towards "Abstract"). On
        one hand, the emphasised reliance on decoupled components and multi-paradigm capabilities means that there is
        strong similarities to JavaScript - where blind trust qualia can thrive. On the other hand, the static type
        system and structured environment forces a compile-time correctness that requires developers have some
        understanding of how their code works underneath.
    </p>
    <p>
        Lastly, <code>C/C++</code>, <code>Rust</code> and <code>Zig</code> would probably fall somewhere around the
        "Practical" marker. In these languages, you are required to understand what you're doing. Calling an interface
        at the wrong time or using the heap instead of the stack can lead to some pretty gnarly bugs. Successfully
        building with these languages requires some in-depth knowledge about how things work under the hood. With so
        much to know and remember, it's hard to build large scale applications with this qualia.
    </p>

    <br />

    <h3>Anecdotal Evidence - Phenomena</h3>
    <p>
        There are a few phenomena that have occurred over the last decade - that could be explained by a mismatch of
        qualia to environment. When you're working in an environment that is not particularly suited to the way your
        brain interprets code, you'll probably find it a lot more difficult. Likewise - those who have a matched qualia
        with their environment find it a lot easier. The emergence of people who identify as "&lt;Framework&gt;
        Developers" probably find their knowledge in said framework to be hard-earned - whilst others have been able to
        pick it up in a day. Furthermore, the "it's common sense" online culture could be (in some cases) mismatched vs
        matched qualia clashing online. Perhaps the reason we can't find a strict set of rules that makes code
        "readable" and "maintainable" is because these differ depending on the qualia match-up of each individual. Code
        comments are critical in environments that are mis-matched to your qualia, and totally unnecessary when working
        with languages that "speak for themselves" (a.k.a. matched qualia).
    </p>
    <p>
        Personally, I've really struggled to become a <code>C#</code> developer. I'm very capable of building working
        solutions - but my solutions have often got <code>C#</code> specific smells or antipatterns. Alternatively,
        <code>JavaScript</code>, <code>F#</code>, <code>Zig</code>, and <code>C</code> have all come very naturally to
        me. <code>Rust</code> and <code>C++</code> have provided a little more difficulty - not with memory management,
        but rather, just the sheer amount of learning required. Yet <code>Ruby</code> and <code>Haskell</code> feel like
        a foreign languages to me. My question that spawned most of this article is: "why?". I feel like I'm a capable
        and competent Software Engineer - but why do I struggle so much with some technologies, and not others? There
        doesn't seem to be some commonality with proximity to metal or user; Nor is there any commonality around
        paradigms.
    </p>
    <p>
        I'm at a stage in my career now, where I've dealt in some situations where I felt like I just could not
        communicate with my fellow Software Engineers. I've found myself questioning the competency of senior developers
        (as an intermediate), and
    </p>
</article>
