<h1>WHAT IS A SOFTWARE ENGINEER? - WIP</h1>
<p>An Observation By: Harrison Cook</p>
<p>29/12/2024</p>
<article>
    <h2>Introductions and Biases</h2>
    <p>
        After spending four long and difficult (albeit - incredibly fulfilling) years at University, I graduated with a
        Bachelor of Engineering - majoring in Software Engineering. Completing this degree gave me euphoria, in that I
        seriously believed I had found my calling in this world. Feeling competent and capable to join the workforce, I
        was eager to grow stronger and expand into specializations based on my academic fundamentals. Unfortunately,
        I've found myself encountering the same reality that many have faced before me; academia and the industry are
        not ... aligned? The best way I could describe this feeling, is through the following analogy:
    </p>
    <blockquote>
        Let's say I've trained to build car engines as an "Automotive Engine Designer", yet I find myself working as an
        "Automotive Service Technician". Both occupations are critical roles in the automotive space, and they have some
        overlap, but they require wildly different ways of thinking about a vehicle.
    </blockquote>
    <p>
        In the pursuit of understanding where I'd like to take my career, this odd feeling really held back my
        understanding of
    </p>
    <p>
        It's worth noting two things before we start. <b>Firstly</b>, I don't believe I am the first person to have
        experienced the above feeling. The theory I am proposing is meant to aid in understanding a more common
        experience. <b>Secondly</b>, this post isn't "solutions" focused. The perspective I'm proposing in this post is
        certainly a work in progress, but I think it does a pretty adequate job of helping me understand the career path
        I'd like to follow, and offers a potential tool for enabling clearer conversations throughout the programming
        community (more on this in a later section).
    </p>

    <br />

    <h2>Background Information</h2>
    <p>
        I was introduced to the idea of "qualia" from a friend; A couple drinks and a philosophical conversation topic
        is a recipe for 3 hour discussions between us. Some time ago, this was just a neat concept that I didn't pay
        much attention to, but when the conversation resurfaced between us recently (at a time when I was considering my
        future career path), it dawned upon me that my education and occupation may have a mismatch of qualia.
    </p>
    <p>
        The following ideas focus around the phenomena of "qualia" (an individuals subjective experiences). Generally
        speaking, human brains are limited in their computational power; They take shortcuts and fill in missing details
        to make sense of the unimaginably large amount of variables and information that is packed into the universe.
        Simply put (for the purposes of this post), qualia is how your brain uniquely <b><i>interprets</i></b> hidden
        information.
    </p>
    <p>
        We can also share qualia with others. Take the following math equation: <code>50 * 14</code>. If you asked a
        dozen people to solve this equation in their head - and then asked them how they found the answer, you'll
        probably find there was a selection of different methods to solving the equation. In the small sample I took
        there was: <code>(50 * 2) * (14 / 2)</code>, <code>50 * 10 + 50 * 4</code>, and
        <code>((50 * 2) * 14) / 2</code>. This is such a small problem, yet there are many different ways of finding a
        solution. You have shared qualia with people who solved the problem the same way you did - in that, you're brain
        and their brain interpreted the same "best" way to solve the problem (the "best" way being the hidden
        information).
    </p>
    <p>
        You are unique because of the specific combination of all qualia that you have - built from the experiences that
        put you where you are. Whilst qualia as a whole is a very large topic, we will be narrowing it down now and to
        explore the qualia of code.
    </p>

    <br />

    <h2>A Spectrum Of Code Interpretations</h2>
    <p>
        The digital world as we know it has grown to an unfathomable scale! Assuming human brain limitations exist (as
        mentioned previously), any one person cannot have a deep understanding with everything in this field (even on an
        abstracted level). I theorize that excelling in any particular partition requires a specialized "qualia"; In
        that, at some point your brain must simply "fill in the blanks" for "hidden information", but where that point
        is makes the difference. The natural progression of programming suggests a continuum of where these qualia may
        lie - from Alan Turing's theories to monolith cloud applications. We could outline the spectrum as such:
    </p>

    <ul>
        <li>
            <b>Theoretical - Computer Scientists</b>
            <p>
                Based heavily in mathematics, Computer Scientists have a set of qualia that is able to make sense of
                logical structures, abstract algorithms, and complex computational problems. This uniquaasfe perspective
                allows them to drive innovation in theoretical technology.
            </p>
        </li>
        <li>
            <b>Practical - Software Engineers</b>
            <p>
                Turning theory into practice requires an <b>intimate</b> understanding of real world constraints (memory
                size, CPU clock speeds, etc). Software Engineers have a set of qualia that enables them to command
                interactions with computers - seeing the minute instructions and actions required to see mathematical
                theory come to life.
            </p>
        </li>
        <li>
            <b>Abstract - Software Developers</b>
            <p>
                Expanding the capabilities of computers for non-technical users requires stitching together a wide range
                of technologies, algorithms, components, etc. For Software Developers, their qualia thrives on the
                abstract - enabling the implementation and management that drives the utility of computing on large
                scales.
            </p>
        </li>
    </ul>

    <p>
        To be crystal clear, the markers above exist as transitions along a continuum. They are not boxes to put each
        individual into. Perhaps you land somewhere between two markers, and in a later section, we'll delve into what
        you might experience working outside your qualia. First, let's look at applying this model to what we see in
        modern programming discourse.
    </p>

    <h3>Anecdotal Evidence #1 - Languages</h3>
    <p>
        With the established spectrum above (and trusting in my proposed model for a moment), lets just discuss some
        anecdotal cases that made me think this model has some merit.
    </p>
    <p>
        <code>Haskell</code> is colloquially known as a "white paper" language - and for good reason. It bridges the gap
        between academic theory and practical implementations, incorporating principles from mathematical research like
        pure functions, lazy evaluation, and advanced type systems. These features, derived from scholarly work, make
        Haskell a powerful tool that transforms theoretical concepts into real-world programming solutions. As one could
        imagine, bringing theory to practice would likely have a paper explaining the theory. On our spectrum, it would
        sit between "Theoretical" and "Practical" - meaning those with lambda calculus orientated qualia (where lambda
        calculus comes more naturally) would have a much easier time using this language in it's intended fashion.
    </p>
    <p>
        <code>JavaScript</code> is often considered a quirky language, frequently ridiculed for its seemingly unexpected
        behaviors. Despite its reputation, JavaScript thrives in the hands of developers who can embrace a sense of
        blind trust. On the spectrum, it would heavily favor those with qualia towards the "Abstract". When combined
        with <code>Node.js</code> and <code>NPM </code>, there is an environment that is brilliant for developers who
        can build efficiently without needing an in-depth understanding beyond an APIs. The frequent release of new
        JavaScript frameworks is often laughed at, but for those with the right qualia, picking up a new framework is a
        trivial task - and the breadth of frameworks enables more specialized implementations. Building larger
        applications becomes significantly more manageable for those in this headspace, allowing developers to focus on
        rapid development.
    </p>
    <p>
        <code>C#</code> has similar characteristics to JavaScript - but brings more structure and rigor to the field.
        Dependency Injection, SOLID Principles and Project Structures are added to the mix, making C# this odd language
        that feels like it sits between "Practical" and "Abstract". However, the emphasised reliance on decoupled
        components and multi-paradigm capabilities means that there is strong similarities to JavaScript - where blind
        trust qualia thrives. The static type system and structured environment gives the appearance of more control and
        stability, but as those who have used this language extensively will know - that is unfortunately not the case
        when you're four layers of interfaces deep.
    </p>
    <p>
        Lastly, <code>C/C++</code> and <code>Zig</code> would probably fall somewhere <i>around</i>
        the "Practical" marker. In these languages, you are required to understand what you're doing. Calling an
        interface at the wrong time or using the heap instead of the stack can lead to some pretty gnarly bugs.
        Successfully building with these languages requires some in-depth knowledge about how things work under the
        hood. With so much to know and remember, it's hard to successfully build large scale applications with this
        qualia.
    </p>

    <h3>Anecdotal Evidence #2 - Phenomena</h3>
    <p>
        There are a few phenomena that have occurred over the last decade, that <i>could</i> be explained by a mismatch
        of qualia to environment. When you're working in an environment that is not particularly suited to the way your
        brain interprets code, you'll probably find it a lot more difficult. Likewise - those who have a matched qualia
        with their environment find it a lot easier. The emergence of people who identify as "&lt;Framework&gt;
        Developers" probably find their knowledge in said framework to be hard-earned - whilst others have been able to
        pick it up in a day. Furthermore, the "it's common sense" online culture could be (in some cases) mismatched vs
        matched qualia clashing online. Perhaps the reason we can't find a strict set of rules that makes code
        "readable" and "maintainable" is because these differ depending on the qualia match-up of each individual. Code
        comments are critical in environments that are mis-matched to your qualia, and totally unnecessary when working
        with languages that "speak for themselves" (a.k.a. matched qualia).
    </p>
    <p>
        Another rather large community space right now is YouTube, where programming content creators have started to
        really make some waves. As a casual viewer (less than 6 hours a week) I've spent some over the past 5 years,
        watching: "ThePrimeagen", "Theo - t3.gg", "Pirate Software", "CodeAesthetic" and "Low Level". At certain points
        in time, I've really connected with the opinions of some of these creators - Theo's opinions against
        <code>TypeScript's</code> static typing (particularly on functions) was one I felt so strongly about, I made
        changes to the standards of our workplace (a large company with ~50 developers). However, there are other times
        I've been in total disagreement with some opinions shared by these creators. It's far too easy to fall into the
        "they're more talented and wise than I, so I guess I'm probably wrong" mindset.
    </p>

    <br />

    <h2>Qualia - Mutability by Default, Hardened Over Time</h2>

    <br />

    <h2>The Conversations WE Have</h2>
</article>
